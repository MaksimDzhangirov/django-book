# Часть 1: Рефакторинг проекта и знакомство с API для настроек Django

В этом разделе рассматриваются вопросы, касающиеся изменения структуры проекта, дается введение в API для настроек Django, а также проверяется работоспособность проекта!

---

## Введение

Для тех, кто только что присоединился к нам, предыдущая часть современного учебника по Django находится здесь: [Часть 0: Введение и начальная настройка](/chast-0-vvedenie-i-nachalnaya-nastroika.md).

GitHub этого проекта и всех его частей можно найти по [этой ссылке](https://github.com/djstein/modern-django).

На данный момент мы успешно создали Django проект. Тем не менее, предстоит ещё много сделать прежде, чем мы сможем сказать, что его можно использовать для локальной разработки и создания нашего первого приложения. Сначала мы должны изменить наш файл зависимостей проекта \(файл `requirements.txt` - прим. переводчика\). Затем мы должны изменить настройки проекта. Мы создадим набор переменных окружения для хранения секретных значений. Все это приведет к увеличению скорости разработки, тестирования и развертывания нашего приложения в будущем.

После изменения настроек, мы пройдемся по стандартной части API для настроек Django, которые используются нашим проектом и были созданы при первом создании `settings.py`. Также мы познакомимся с некоторыми часто используемыми настройками не создаваемыми по умолчанию, например, касающиеся обработки статических файлов. Понимание API для настроек Django - это первый шаг, позволяющий пролить свет на то, что называется _Магией Django_. Мы проведем ещё одну небольшую реструктуризацию и затем убедимся в работоспособности проекта!

Важно, чтобы все новые пользователи чувствовали себя уверенно при работе с настройками Django, поэтому я извиняюсь перед теми из Вас, кто хорошо знает Django или хочет начать работать с [REST API](https://en.wikipedia.org/wiki/Representational_state_transfer). Я могу только попробовать развеселить Вас во время изучения частей касающихся настроек, как эта \(на этот раз все смешные картинки находятся внизу\).

**Замечание:** Будем откровенны. В этой части Вы увидите структуру приложения, аналогичную структуре, которую создала [Django команда Cookiecutter](https://github.com/pydanny/cookiecutter-django) \(**C**ookie**c**utter **D**jango - CCD\). Если мы не будем использовать CCD проект, то в конечном итоге просто расширим базовый Django проект, пока нам не понадобятся какие-то более сложные части, поэтому мне кажется, что такой способ лучше. Команда CCD столкнулась с множеством локальных и продакшен проблем и решила их. Я принял во внимание их структуру, сравнивая её с той, что нужна нам. Хотя на ранних стадиях наш проект может казаться похожим на их, важно пояснить что делается на каждом этапе вместо того, чтобы слепо создавать шаблонный проект. Наш проект будет сильно отличаться в будущем , но сейчас Вы можете заметить структурное сходство. Например, существенная разница будет заключаться в том, что мы удалим формирование страниц на стороне сервера \(как это делается в CDD и многих других проектах\), а будем использовать REST API в сочетании с фронтэнд JavaScript фреймворком.

**Временное замечание:** Это замечание касается тех, кто использовал старую версию Части 0 \(до 24/02/2017\), поскольку мы обновили структуру проекта. В частности была обновлена команда `django-admin startproject` из части 0. Простите, ребята. Чтобы привести старую структуру приложения к новой потребуется большое количество изменений. Поэтому проще для всех будет, если те, кто использовал старую версию Части 0, просто удалят каталог `project` и создадут проект, используя новое имя и путь.

Для этого перейдите в каталог `modern-django`, удалите старый проект и создайте новый. Используйте команды:

```
# Команды
cd ~/git/modern-django/
rm -rf project/
django-admin startproject config .
```

> Примечание переводчика. Эта часть переводилась после 24/02/2017, следовательно, ничего исправлять не надо.

## Используемые технологии

В этой части мы изучим намного меньше технологий.

* Django настройки: "Файл с настройками Django содержит полную конфигурацию установленного Django проекта” \([источник](https://docs.djangoproject.com/en/1.10/topics/settings/)\). Это набор файлов/конфигураций, которые мы изучим в этой части! Это основа любого Django проекта.
* Переменные окружения \(переменные среды\): "Набор динамически задаваемых значений, которые могут повлиять на поведение запущенных процессов в компьютере. Они являются частью среды, в которой выполняется процесс" \([источник](https://en.wikipedia.org/wiki/Environment_variable)\). Мы создадим множество переменных окружения в процессе изучения.
* django-environ: "Позволяет Вам, используя 12 переменных окружения, настраивать Ваше Django приложение" \([источник](https://github.com/joke2k/django-environ)\). Мы установим этот пакет, чтобы упростить работу с переменными окружения для Django!

## Подробное пошаговое руководство

Продолжая с того места, на котором мы остановились в части 0, наша текущая структура проекта выглядит следующим образом!

```
modern-django
├── LICENSE
├── README.md
├── config
│   ├── __init__.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
├── manage.py
└── requirements.txt
```

С этого момента, я буду предполагать, что Вы находитесь в каталоге `modern-django`, если не указано иное. Чтобы перейти в каталог `modern-django`, используйте следующую команду:

```
# Команда
cd ~/git/modern-django/
```

### 1. Изменяем requirements.txt

В этом разделе мы осуществим рефакторинг `requirements.txt`, сделав его намного более удобным в эксплуатации. Сначала создайте каталог с названием `requirements` в каталоге `modern-django`. Затем скопируйте текущий файл `requirements.txt` в него, переименовав в base.txt. После этого перейдите в каталог `requirements` и создайте файлы с зависимостями для локального, продакшен и тестового окружения.

```
# Команда
mkdir requirements/
mv requirements.txt requirements/base.txt
cd requirements/
touch local.txt production.txt test.txt
```

Теперь мы можем изменять список Python приложений, которые будет использовать наше виртуальное окружение \(или [Docker](https://en.wikipedia.org/wiki/Docker_%28software%29) образ\), основываясь на окружении \(локальная разработка, продакшен или  тестирование\).

#### 1-A. Добавляем django-environ в base.txt {#3c5a}

В файл base.txt, на основе которого будут создаваться все окружения, добавим [django-environ](https://github.com/joke2k/django-environ). Это позволит упростить настройку Django сразу по двум направлениям:

1. Упрощает использование переменных окружения
2. Упрощает пути к файлам

Откройте файл `requirments/base.txt` в Вашем любимом текстовом редакторе и добавьте следующую строку под `django==1.10.5`:

```
django-environ==0.4.1
```

#### **1-B. Осуществляем наследование локальных, продакшен и тестовых зависимостей от base.txt**

Теперь в наши файлы local.txt, production.txt и test.txt мы добавим строку, которая будет рекурсивно получать все зависимости из base.txt. Добавим эту строку в начало только что созданных файлов:

```
-r base.txt
```

Аналогично тому как мы добавили `django` в старый файл `requirements.txt` в части 0, мы будем продолжать добавлять сторонние приложения в проект, используя один из этих файлов. Новые строки будут добавлены в этот файл позднее, во время изучения пособия, а сейчас пора обратить внимание на `settings.py`.

### 2. Изменяем settings.py

В этом разделе, мы осуществим рефакторинг `settings.py`, сделав его более удобным в эксплуатации и разделим его аналогично тому как мы сделали это с `requirements.txt`.  Сначала создадим новый каталог `settings` внутри `config`:

```
# Команда
mkdir config/settings/
```

Теперь переместите файл `settings.py` в каталог `settings` и переименуйте в `base.py`:

```
# Команда
mv config/settings.py config/settings/base.py
```

Далее создайте файлы с настройками для каждого окружения \(локального, продакшен и тестового\):

```
# Команда
cd config/settings/
touch local.py production.py test.py
```

Опять в Вашем любимом текстовом редакторе в начале `local.py`, `production.py` и `test.py` импортируйте `base.py`, добавив:

```
from .base import *
```

Теперь, заложив основу, поря просмотреть и реорганизовать файл настроек `base.py`.

**Замечание:** В вышеприведенной строке импорт осуществлялся следующим образом: `import *`.  Хороший специалист импортирует только те части классов/модулей/библиотек, которые ему необходимы, но этот случай, является исключением.

### 3. Знакомство с API для настроек Django

Пока в base.py находятся только стандартные настройки, созданные командой `django-admin startproject`. Ниже мы рассмотрим каждую настройку одну за другой - определим её своими словами и отредактируем в случае необходимости.

#### 3-A. Добавляем django-environ

Как описано в вышеприведенных разделах, пакет django-environ позволяет упростить использование переменных окружения и пути к файлам.

В `base.py` найдите строку `import os` под сгенерированными комментариями. Этот импорт используется в нескольких местах для получения путей к файлам. Использование `environ` позволяет упростить реализацию этой задачи. Таким образом, найдите строку `import os` и замените её импортом `environ` в начале `base.py`:

```
import environ
```

#### 3-B. Переменные, отвечающие за пути к файлам: меняем BASE\_DIR на ROOT\_DIR + APPS\_DIR {#e994}

Теперь, когда мы удалили `import os`, изменим переменную `BASE_DIR`. `BASE_DIR` обычно используется для создания переменных, хранящих пути к файлам относительно верхнего уровня проекта \(корневого каталога\), т. е. для указания пути к файлу или каталогу с файлами.

Теперь, когда мы импортировали `environ`, мы можем заменить `BASE_DIR`  другой переменной, которую назовём `ROOT_DIR` \(Вы можете просто переименовать переменную или оставить её старое название, но `ROOT_DIR` звучит логичнее, учитывая то, за что отвечает данная переменная\). Добавьте следующую строку:

```
ROOT_DIR = environ.Path(__file__) - 3
```

Эта функция возвращает текущий путь к файлу `~/git/modern-django/config/base.py` и поднимается на три уровня вверх `~/git/modern-django/`. Теперь у нас есть переменная, которая указывает на корневой каталог проекта и мы можем получить путь к любому файлу в каталоге, используя её.

Продемонстрируем, что мы можем получить доступ к любому другому файлу, создав другую переменную, которую назовём `APPS_DIR`. В ней будет храниться путь к ещё не созданному каталогу, в котором позднее будут храниться создаваемые нами приложения. Добавьте переменную `APPS_DIR` ниже `ROOT_DIR`:

```
APPS_DIR = ROOT_DIR.path('project')
```

#### 3-C. Импортируем переменные окружения {#674f}

Ниже только что созданных `ROOT_DIR` и `APPS_DIR`, мы импортируем множество переменных окружения из файла `.env` \(мы его скоро создадим\), которые будут использоваться в проекте. Воспользуемся функцией `environ.Env()` для поиска `.env` файла к нашем корневом каталоге проекта, а затем `read_env()`, чтобы считать переменные из файла. Для этого добавьте следующие строки:

```
env = environ.Env()

# Эта часть добавлена из CookieCutter Django и гарантирует отсутствие ошибок при запуске локального сервера/миграциях
READ_DOT_ENV_FILE = env.bool('DJANGO_READ_DOT_ENV_FILE', default=False)

if READ_DOT_ENV_FILE:
    env_file = str(ROOT_DIR.path('.env'))
    print('Loading : {}'.format(env_file))
    env.read_env(env_file)
    print('The .env file has been loaded. See base.py for more information')
```

**Замечание:** Основная причина добавления этого функционала именно сейчас заключается в том, что при использовании [Docker](https://en.wikipedia.org/wiki/Docker_%28software%29) контейнеров, мы будем считывать переменные окружения из `.env` файла, поскольку могут возникнуть некоторые сложности, если делать это через Docker.

#### 3-D. Вводная информация о SECRET\_KEY и перемещение его в `local.py` {#010f}

**!!! ЕСЛИ ВЫ НЕ ЧИТАЛИ ДРУГИЕ РАЗДЕЛЫ, ОБЯЗАТЕЛЬНО ПРОЧИТАЙТЕ ЭТОТ !!!**

После добавления переменных окружения, мы должны настроить `SECRET_KEY`. Секретный ключ в Django чрезвычайно важная переменная и как следует из названия его необходимо держать в тайне. Тем не менее, мы уже передали наш секретный ключ в публичный \(если конечно Вы не создавали приватный репозиторий - прим. переводчика\) репозиторий на GitHub. Не волнуйтесь, это было сделано специально для локальной разработки и позволяет использовать ключ для различных окружений и другими разработчиками. **Учтите, что мы создадим другой секретный ключ при развертывании нашего приложения и он не должен отслеживать системой управления версиями и совместно использоваться с кем-либо.**

Секретный ключ используется в различных частях проекта, например, при создании пользовательских сессий, сообщений, cookies, сбросов паролей и криптографической подписи. Поэтому он очень важен. [Узнать больше о нём можно из официальной документации](https://docs.djangoproject.com/en/1.10/ref/settings/#secret-key).

Для локальной разработки, мы вырежем и вставим \(удалив значение из `base.py`\), переменную `SECRET_KEY` в local.py и отредактируем строку, чтобы она стала выглядеть следующим образом \(значение Вашего ключа будет отличаться от приведенного ниже\):

```
SECRET_KEY = env('DJANGO_SECRET_KEY', default='^92l&5_l2f-ik5xlav!7*cat904fro-lmdd@0kgz@c*nxua3@p')
```

#### 3-E. Вводная информация о DEBUG {#e204}

Следующей по порядку является настройка `DEBUG`. Сейчас она равна `True`.  Когда `DEBUG` равно `True`, происходит множество вещей, например: выводятся страницы с подробными сообщениями об ошибках, сохраняются все осуществленные SQL запросы и переменная ALLOWED\_HOSTS может быть не заполнена. [Узнать больше о `DEBUG` можно здесь](https://docs.djangoproject.com/en/1.10/ref/settings/#debug). Мы должны всегда предполагать, что переменная `DEBUG` будет равна `False`, за исключением случая локальной разработки, когда она равна `True`. Отредактируем текущее значение в `base.py`, приравняв значение переменной окружения к `False`.

```
DEBUG = env.bool('DJANGO_DEBUG', False)
```

Использовать значение `True` для `DEBUG` следует только при локальной разработке, поэтому мы должны также скопировать переменную в `local.py`. Скопируйте и вставьте переменную `DEBUG` в `local.py` и измените значение переменной окружения, приравняв её к `True`.

```
DEBUG = env.bool('DJANGO_DEBUG', default=True)
```

Создание переменной окружения DEBUG позволяет нам более эффективно настраивать инструменты для развертывания, основываясь на значениях переменных окружения!

#### 3-F. Вводная информация о ALLOWED\_HOSTS {#814b}

`ALLOWED_HOSTS` - это список сайтов, с которыми Django может устанавливать соединение и принимать запросы. Для локальной разработки, когда `DEBUG` равно `True`, значение может быть равно пустому списку, но при переходе на продакшен сервер, оно должно быть изменено на определенный домен, например, `.example.com`.

Мы вернемся к этой настройке при развертывании. Пока просто вырежьте и вставьте `ALLOWED_HOSTS` в `production.py` после всех импортов.

#### 3-G. Вводная информация о INSTALLED\_APPS {#c0ad}

Массив `INSTALLED_APPS` - это список всех приложений, которые будут использоваться в Django проекте. Он инициализируется набором из стандартных Django приложений, позволяющих запустить базовый проект. Как правило, приложение просто добавляется в список, после установки через `pip` или создания разработчиком. Однако для более удобной организации проекта разделим `INSTALLED_APPS` на три кортежа: `DJANGO_APPS`, `THIRD_PARTY_APPS` и `LOCAL_APPS`. После заполнения трех кортежей, объединим их в одном списке `INSTALLED_APPS`.

**Замечание:** Мы используем кортежи вместо списков, поскольку они являются неизменяемыми и их легко объединять. Их неизменяемость также гарантирует, что во время работы список установленных приложений для проекта нельзя будет изменить.

Итак, пока единственными установленными приложениями являются стандартные Django приложения. Изменим структуру , чтобы отразить это:

```
DJANGO_APPS = (
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
)

THIRD_PARTY_APPS = (
)

LOCAL_APPS = (
)

INSTALLED_APPS = DJANGO_APPS + THIRD_PARTY_APPS + LOCAL_APPS
```

Когда мы начнем устанавливать сторонние приложения и создавать наше REST API, мы заполним два пустых кортежа.

#### 3-H. Вводная информация о MIDDLEWARE {#b745}

Следующей по порядку является таинственная настройка `MIDDLEWARE` \(Промежуточные слои\). Она отвечает за обработку запросов/ответов \(HTTP коммуникацию\) в момент входа/выхода в/из Django и применение к ним функций до/после того как они будут обработаны. Примером может быть AuthenticationMiddleware, которое может связать пользователя с запросом, если используются пользовательские сессии. Эти функции работают очень быстро и помогают добавить что-то к данным, которые мы обрабатываем.

**ВНИМАНИЕ: Порядок расположения промежуточных слоёв в списке **`MIDDLEWARE`** определяет порядок, в котором они будут обработаны. Это означает, что создаваемые пользователями промежуточные слои должны располагаться выше других , иначе это может привести к непредвиденному поведению.**

В документации к Django этот процесс описывается в виде слоёв луковицы, где Представление \(и его потомки\) - это сердцевина луковицы, а запрос должен пройти через каждый промежуточный слой, оборачивающий сердцевину, перед тем как его сможет обработать представление.

[Чтобы узнать больше о промежуточных слоях, воспользуйтесь этой страницей из документации.](https://docs.djangoproject.com/en/1.10/topics/http/middleware/)

Пока что оставим эту настройку не тронутой!

#### 3-I. Вводная информация о ROOT\_URLCONF {#4cf0}

`ROOT_URLCONF` указывает на URLconf модуль \(набор URL правил\), с помощью которых Django обрабатывает запросы/ответы. На самом деле, когда пользователь запрашивает страницу/ресурс в одном из наших приложений, Django просматривает этот файл, чтобы определить что делать. То есть, `ROOT_URLCONF` определяет путь к файлу , который содержит набор URL -адресов, например, `modern-django/config/urls.py`. Этот путь используется по умолчанию и мы добавим больше URL адресов в файл, например, те, которые будут использоваться в нашем REST API, позднее. На данный момент в файле `modern-django/config/urls.py` прописаны URL-адреса, позволяющие получить доступ к админке.

#### 3-J. Вводная информация о TEMPLATES {#c89b}

Переменная `TEMPLATES` содержит список настроек для установленных шаблонизаторов. Можно установить множество, однако, для большинства проектов хватает одного. Настройки по умолчанию включают:

* `BACKEND`: обработчик для создания шаблонов
* DIRS: каталоги, в которых Django будет искать файлы шаблонов
* APP\_DIRS: если равно True, то Django будет автоматически искать в каждом приложении из списка INSTALLED\_APPS шаблоны, которые могут быть отрендерены
* OPTIONS: дополнительные параметры, которые зависят от BACKEND
* context\_processors: параметр, который используется движком DjangoTemplates и определяет как данные отображаются в шаблоне. [Подробнее смотрите здесь.](https://docs.djangoproject.com/en/1.10/topics/templates/#django.template.backends.django.DjangoTemplates)

[Больше информации о настройках можно найти здесь.](https://docs.djangoproject.com/en/1.10/ref/settings/#templates)

_Чтобы стало понятно для чего нужна каждая настройка, мы вернемся и подробно рассмотрим этот раздел позднее, когда начнем использовать JavaScript фронтэнд с нашим API._

#### 3-K. Вводная информация о WSGI\_APPLICATION {#9c54}

"WSGI" - это сокращение от **W**eb **S**erver **G**ateway **I**nterface \(интерфейс шлюза Web-сервера\). Это стандарт для Python веб-фреймворков, определяющий сервер, который будет использоваться приложением.

`WSGI_APPLICATION` определяет путь к файлу `wsgi.py`, который будет использоваться Django при выполнении команды `runserver`. Файл содержит переменную application и текущее значение этой переменной указывает на функцию get\_wsgi\_application. Она является основой для запуска нашего приложения. [Более подробную информацию можно найти здесь.](https://docs.djangoproject.com/en/1.10/ref/settings/#wsgi-application)

#### 3-L. Вводная информация о DATABASES {#792d}

Переменная `DATABASES` позволяет подключать различные базы данных к нашему проекту. В ней хранятся настройки , необходимые для взаимодействия с различными базами данных. Базой данных используемой по умолчанию является сохраняемая локально [sqlite3](https://www.sqlite.org/) база данных \(которая ещё не была создана, поскольку мы не совершали пока никаких манипуляций с базой данных. Пока\). Позднее мы изменим настройки, добавив базу данных [PostgreSQL](https://www.postgresql.org/), когда начнем работать с [Docker](https://en.wikipedia.org/wiki/Docker_%28software%29).

Здесь опять используется `os`, поэтому необходимо заменить эту строку на путь, создаваемый с помощью `environ`. Замените строку `NAME` на следующую:

```
'NAME': str(ROOT_DIR.path('db.sqlite3')),
```

#### 3-M. Вводная информация о AUTH\_PASSWORD\_VALIDATORS {#0a4c}

Эта настройка представляет собой набор правил, использующихся для проверки паролей при их создании или редактировании пользователями. Значений по умолчанию достаточно, чтобы защитить пароли от большей части атак и не требуется никаких дополнительных настроек. [Вы можете использовать собственные валидаторы для увеличения уровня защищенности как описано здесь.](https://docs.djangoproject.com/en/1.10/topics/auth/passwords/#password-validation)

#### 3-N. Вводная информация об интернационализации {#75e2}

Раздел с переменными `LANGUAGE_CODE`, `TIME_ZONE`, `USE_I18N`, `USE_L10N` и `USE_TZ` используется для форматирования данных и выбора языка для различных пользователей. Поступило предложение более подробно рассмотреть эту тему позднее, тем не менее для большинства американских/английских сайтов значений по умолчанию более чем достаточно. [Документацию к этим настройкам можно найти здесь](https://docs.djangoproject.com/en/1.10/topics/i18n/).

#### 3-O. Вводная информация о статических и медиа файлах {#9d5b}

Статические файлы - это файлы, считающиеся неизменяемыми, статическими. Такими файлами являются, например, изображения, CSS и JavaScript файлы, которые используются в приложении. Медиа файлами считаются динамические файлы, создаваемые/редактируемые/загружаемые пользователями. Большинство рассматриваемых ниже правил применяется как к статическим, так и медиа файлам.

Сейчас мы рассматривает одно из самых сложных понятий, которое нужно уяснить новичкам в Django. Существует только один стандартный способ настройки работы со статическими/медиа файлами, но многие пользователи начинают теряться, когда дело доходит до этого.

**Очень важно понять, что сейчас статические файлы находятся в отдельных каталогах, соответствующих приложению, к которому они относятся. Но это не то место, где они будут находиться при переходе на продакшен сервер.**

Например, CSS файлы, используемые для панели администрирования, будут браться не из статического каталога приложения для администрирования на продакшен сервере. При развертывании используется команда `collectstatic` из файла `manage.py`. Она копирует все статические файлы, которые указаны в файле настроек, в корневой каталог, определенный в переменной `STATIC_ROOT`. Затем сервер, например, [nginx](https://www.nginx.com/resources/wiki/), получает и работает с этими файлами.

Тем не менее, при локальной разработке, Django использует файлы из тех каталогов, где они на самом деле находятся.

Пока, `STATIC_URL` - это единственная настройка для статических файлов, создаваемая по умолчанию. Это URL, указывающий где будут находится статические файлы. В настоящее время файлы будут находится по адресу `localhost:8000/static`, если адрес `localhost:8000` используется для локальной разработки.

Мы добавим следующие настройки:

* `STATIC_ROOT`: абсолютный путь к каталогу, в который будут собраны все статические файлы
* `STATICFILES_DIRS`: каталоги, в которых Django будет искать статические файлы
* `STATICFILES_FINDERS`: бекэнды для поиска статических файлов
* `MEDIA_URL`: URL, который добавляется к корневому URL при работе с медиа файлами
* `MEDIA_ROOT`: абсолютный путь к каталогу, в котором будут хранится собранные медиа-файлы

Добавьте эти настройки к части, касающейся настройки статических и медиа файлов, после `STATIC_URL` в `base.py`:

```
STATIC_URL = '/static/'
STATIC_ROOT = str(ROOT_DIR('staticfiles'))
STATICFILES_DIRS = (
    str(APPS_DIR.path('static')),
)
STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
)
MEDIA_URL = '/media/'
MEDIA_ROOT = str(APPS_DIR('media'))
```

---



